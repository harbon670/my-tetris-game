<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Tetris Ultimate</title>
  <style>
    body { background: #000; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; color: #fff; font-family: 'Courier New', Courier, monospace; overflow: hidden; }
    canvas { border: 4px solid #333; background: #0a0a0a; box-shadow: 0 0 20px rgba(0,255,255,0.2); }
    #stats { position: absolute; top: 10px; text-align: center; width: 100%; }
    .info { font-size: 20px; text-transform: uppercase; letter-spacing: 2px; }
  </style>
</head>
<body>
  <div id="stats"><div class="info" id="score-display">Игрок: 0 | Speed: 1</div></div>
  <canvas width="320" height="640" id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const context = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score-display');
    const grid = 32;
    const playerName = prompt("Ваше имя", "Игрок") || "Игрок";
    
    let tetrominoSequence = [], playfield = [], score = 0, count = 0, speed = 35, gameOver = false;

    // Инициализация поля
    for (let row = -2; row < 20; row++) { playfield[row] = new Array(10).fill(0); }

    // Полные матрицы фигур
    const tetrominos = {
      'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      'J': [[1,0,0],[1,1,1],[0,0,0]],
      'L': [[0,0,1],[1,1,1],[0,0,0]],
      'O': [[1,1],[1,1]],
      'S': [[0,1,1],[1,1,0],[0,0,0]],
      'Z': [[1,1,0],[0,1,1],[0,0,0]],
      'T': [[0,1,0],[1,1,1],[0,0,0]]
    };

    const colors = { 'I': '#00f0f0', 'O': '#f0f000', 'T': '#a000f0', 'S': '#00f000', 'Z': '#f00000', 'J': '#0000f0', 'L': '#f0a000' };

    function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

    function generateSequence() {
      const sequence = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
      while (sequence.length) {
        const rand = getRandomInt(0, sequence.length - 1);
        tetrominoSequence.push(sequence.splice(rand, 1)[0]);
      }
    }

    function getNextTetromino() {
      if (tetrominoSequence.length === 0) generateSequence();
      const name = tetrominoSequence.pop();
      return { name, matrix: tetrominos[name], row: name === 'I' ? -1 : -2, col: 3 };
    }

    function rotate(matrix) { return matrix.map((_, i) => matrix.map(row => row[i]).reverse()); }

    function isValidMove(matrix, cellRow, cellCol) {
      for (let r = 0; r < matrix.length; r++) {
        for (let c = 0; c < matrix[r].length; c++) {
          if (matrix[r][c]) {
            if (cellCol + c < 0 || cellCol + c >= 10 || cellRow + r >= 20 || (cellRow + r >= 0 && playfield[cellRow + r][cellCol + c])) return false;
          }
        }
      }
      return true;
    }

    function placeTetromino() {
      tetromino.matrix.forEach((row, r) => {
        row.forEach((value, c) => {
          if (value) {
            if (tetromino.row + r < 0) return (gameOver = true);
            playfield[tetromino.row + r][tetromino.col + c] = tetromino.name;
          }
        });
      });

      for (let r = 19; r >= 0; r--) {
        if (playfield[r].every(cell => !!cell)) {
          score += 100;
          // Ускоряем каждые 500 очков
          if (score % 500 === 0 && speed > 5) speed -= 3;
          playfield.splice(r, 1);
          playfield.unshift(new Array(10).fill(0));
          r++;
        }
      }
      scoreDisplay.innerText = `${playerName}: ${score} | Speed: ${Math.round((35/speed)*10)/10}`;
      tetromino = getNextTetromino();
      if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)) gameOver = true;
    }

    let tetromino = getNextTetromino();

    function loop() {
      if (gameOver) {
        context.fillStyle = 'rgba(0,0,0,0.8)'; context.fillRect(0, 280, 320, 80);
        context.fillStyle = '#ff0000'; context.font = '24px monospace'; context.textAlign = 'center';
        context.fillText('GAME OVER', 160, 330);
        return;
      }
      requestAnimationFrame(loop);
      context.clearRect(0, 0, canvas.width, canvas.height);

      // Сетка (дизайн)
      context.strokeStyle = '#111';
      for(let i=0; i<320; i+=grid) { context.strokeRect(i, 0, 1, 640); }
      for(let i=0; i<640; i+=grid) { context.strokeRect(0, i, 320, 1); }

      playfield.forEach((row, r) => row.forEach((cell, c) => {
        if (cell) {
          context.fillStyle = colors[cell];
          context.fillRect(c * grid, r * grid, grid - 1, grid - 1);
        }
      }));

      if (++count > speed) {
        tetromino.row++; count = 0;
        if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)) { tetromino.row--; placeTetromino(); }
      }

      context.fillStyle = colors[tetromino.name];
      tetromino.matrix.forEach((row, r) => row.forEach((value, c) => {
        if (value) context.fillRect((tetromino.col + c) * grid, (tetromino.row + r) * grid, grid - 1, grid - 1);
      }));
    }

    document.addEventListener('keydown', e => {
      if (gameOver) return;
      if (e.keyCode === 37 || e.keyCode === 39) {
        const col = e.keyCode === 37 ? tetromino.col - 1 : tetromino.col + 1;
        if (isValidMove(tetromino.matrix, tetromino.row, col)) tetromino.col = col;
      }
      if (e.keyCode === 38) {
        const matrix = rotate(tetromino.matrix);
        if (isValidMove(matrix, tetromino.row, tetromino.col)) tetromino.matrix = matrix;
      }
      if (e.keyCode === 40) {
        if (isValidMove(tetromino.matrix, tetromino.row + 1, tetromino.col)) tetromino.row++;
      }
    });

    requestAnimationFrame(loop);
  </script>
</body>
</html>
