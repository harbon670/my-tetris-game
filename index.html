<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Tetris Mobile</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body { background: #050505; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; color: #fff; font-family: sans-serif; overflow: hidden; touch-action: manipulation; }
    canvas { border: 2px solid #333; background: #000; max-height: 70vh; max-width: 95vw; }
    #score { font-size: 24px; margin-bottom: 10px; color: #0ff; text-shadow: 0 0 10px #0ff; }
    
    /* Стили для круглых кнопок */
    .controls { display: grid; grid-template-columns: repeat(3, 70px); grid-gap: 15px; margin-top: 20px; }
    .btn { width: 70px; height: 70px; background: rgba(255,255,255,0.1); border: 2px solid #fff; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; color: #fff; user-select: none; cursor: pointer; -webkit-tap-highlight-color: transparent; }
    .btn:active { background: rgba(255,255,255,0.3); transform: scale(0.9); }
    .btn.rotate { grid-column: 2; border-color: #f0f; box-shadow: 0 0 10px #f0f; }
    .btn.left { grid-column: 1; border-color: #0ff; box-shadow: 0 0 10px #0ff; }
    .btn.right { grid-column: 3; border-color: #0ff; box-shadow: 0 0 10px #0ff; }
    .btn.down { grid-column: 2; border-color: #ff0; box-shadow: 0 0 10px #ff0; }
  </style>
</head>
<body>

  <div id="score">SCORE: 0</div>
  <canvas width="320" height="640" id="game"></canvas>

  <div class="controls">
    <div class="btn rotate" onpointerdown="move('rotate')">↻</div>
    <div class="btn left" onpointerdown="move('left')">←</div>
    <div class="btn down" onpointerdown="move('down')">↓</div>
    <div class="btn right" onpointerdown="move('right')">→</div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const context = canvas.getContext('2d');
    const grid = 32;
    let score = 0;
    let count = 0;
    let gameOver = false;

    const tetrominos = {
      'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      'J': [[1,0,0],[1,1,1],[0,0,0]],
      'L': [[0,0,1],[1,1,1],[0,0,0]],
      'O': [[1,1],[1,1]],
      'S': [[0,1,1],[1,1,0],[0,0,0]],
      'Z': [[1,1,0],[0,1,1],[0,0,0]],
      'T': [[0,1,0],[1,1,1],[0,0,0]]
    };

    const colors = { 'I': '#0ff', 'O': '#ff0', 'T': '#a0f', 'S': '#0f0', 'Z': '#f00', 'J': '#00f', 'L': '#f70' };

    let playfield = [];
    for (let row = -2; row < 20; row++) playfield[row] = new Array(10).fill(0);

    let sequence = [];
    function genSeq() {
      const s = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
      while (s.length) sequence.push(s.splice(Math.floor(Math.random()*s.length), 1)[0]);
    }

    function getNext() {
      if (!sequence.length) genSeq();
      const name = sequence.pop();
      return { name, matrix: tetrominos[name], row: name === 'I' ? -1 : -2, col: 3 };
    }

    function rotate(matrix) { return matrix.map((_, i) => matrix.map(row => row[i]).reverse()); }

    function isValid(matrix, cellRow, cellCol) {
      for (let r = 0; r < matrix.length; r++) {
        for (let c = 0; c < matrix[r].length; c++) {
          if (matrix[r][c] && (cellCol + c < 0 || cellCol + c >= 10 || cellRow + r >= 20 || playfield[cellRow + r]?.[cellCol + c])) return false;
        }
      }
      return true;
    }

    let tetromino = getNext();

    function move(dir) {
      if (gameOver) return;
      if (dir === 'left' && isValid(tetromino.matrix, tetromino.row, tetromino.col - 1)) tetromino.col--;
      if (dir === 'right' && isValid(tetromino.matrix, tetromino.row, tetromino.col + 1)) tetromino.col++;
      if (dir === 'down' && isValid(tetromino.matrix, tetromino.row + 1, tetromino.col)) tetromino.row++;
      if (dir === 'rotate') {
        const m = rotate(tetromino.matrix);
        if (isValid(m, tetromino.row, tetromino.col)) tetromino.matrix = m;
      }
    }

    function loop() {
      if (gameOver) {
        context.fillStyle = 'white'; context.font = '30px Arial'; context.textAlign = 'center';
        context.fillText('GAME OVER', canvas.width/2, canvas.height/2);
        return;
      }
      requestAnimationFrame(loop);
      context.clearRect(0,0,canvas.width,canvas.height);

      playfield.forEach((row, r) => row.forEach((cell, c) => {
        if (cell) { context.fillStyle = colors[cell]; context.fillRect(c*grid, r*grid, grid-1, grid-1); }
      }));

      if (++count > 35) {
        tetromino.row++; count = 0;
        if (!isValid(tetromino.matrix, tetromino.row, tetromino.col)) {
          tetromino.row--;
          tetromino.matrix.forEach((row, r) => row.forEach((v, c) => {
            if (v) { if (tetromino.row + r < 0) gameOver = true; else playfield[tetromino.row+r][tetromino.col+c] = tetromino.name; }
          }));
          for (let r = 19; r >= 0; r--) {
            if (playfield[r].every(v => !!v)) {
              score += 100; document.getElementById('score').innerText = "SCORE: " + score;
              playfield.splice(r, 1); playfield.unshift(new Array(10).fill(0)); r++;
            }
          }
          tetromino = getNext();
        }
      }

      context.fillStyle = colors[tetromino.name];
      tetromino.matrix.forEach((row, r) => row.forEach((v, c) => {
        if (v) context.fillRect((tetromino.col+c)*grid, (tetromino.row+r)*grid, grid-1, grid-1);
      }));
    }

    // Клавиатура для ПК
    document.addEventListener('keydown', e => {
      if (e.keyCode === 37) move('left');
      if (e.keyCode === 39) move('right');
      if (e.keyCode === 38) move('rotate');
      if (e.keyCode === 40) move('down');
    });

    requestAnimationFrame(loop);
  </script>
</body>
</html>
