<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Tetris Ghost Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body { background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; color: #fff; font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none; }
    
    #ui { 
      text-align: center; margin-bottom: 10px; cursor: pointer; user-select: none;
      background: rgba(255,255,255,0.05); padding: 12px 25px; border-radius: 20px;
      border: 1px solid rgba(0,255,255,0.3); transition: transform 0.1s;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    #ui:active { transform: scale(0.92); background: rgba(255,255,255,0.1); }
    
    #score { font-size: 28px; color: #0ff; text-shadow: 0 0 10px #0ff; margin: 0; font-weight: bold; }
    #score::before { content: '‚è∏ '; font-size: 18px; opacity: 0.8; }
    
    #pause-hint { font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 1px; margin: 4px 0; }
    #high-score { font-size: 14px; color: #f70; margin: 0; font-weight: bold; opacity: 0.9; }

    canvas { border: 4px solid #222; background: #050505; border-radius: 8px; max-height: 70vh; max-width: 95vw; box-shadow: 0 0 20px rgba(0,255,255,0.05); }
    .paused-msg { position: absolute; font-size: 42px; font-weight: bold; color: #0ff; background: rgba(0,0,0,0.85); padding: 30px; border-radius: 20px; display: none; pointer-events: none; z-index: 10; border: 2px solid #0ff; }
  </style>
</head>
<body>

  <div id="ui" onclick="togglePause()">
    <p id="score">SCORE: 0</p>
    <div id="pause-hint">–ù–∞–∂–º–∏, —á—Ç–æ–±—ã –ø–∞—É–∑–∞</div>
    <p id="high-score">BEST: 0</p>
  </div>

  <div id="pause-msg" class="paused-msg">–ü–ê–£–ó–ê</div>
  <canvas width="320" height="640" id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const context = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high-score');
    const pauseMsg = document.getElementById('pause-msg');
    
    const grid = 32;
    let score = 0, count = 0, gameOver = false, isPaused = false;
    let flashLines = [];
    let endPhrase = "";

    const funnyPhrases = [
      "–ö–ò–†–ü–ò–ß–ò –ü–û–ë–ï–î–ò–õ–ò üß±", "–ì–ï–û–ú–ï–¢–†–ò–Ø ‚Äî –≠–¢–û –°–õ–û–ñ–ù–û", "–ü–ê–õ–¨–¶–´ –ó–ê–ü–õ–ï–¢–ê–Æ–¢–°–Ø?",
      "–ù–£, –ü–û–ß–¢–ò –ü–û–õ–£–ß–ò–õ–û–°–¨...", "–ì–î–ï –ú–û–Ø –ü–ê–õ–ö–ê? (I-–±–ª–æ–∫)", "–û–ô, –í–°–Å! üôÑ",
      "–≠–¢–û –ë–´–õ –•–ò–¢–†–´–ô –ü–õ–ê–ù?", "–¢–ï–¢–†–ò–°: 1, –¢–´: 0", "–ü–û–¢–†–ê–ß–ï–ù–û"
    ];

    let highScore = localStorage.getItem('tetris-best-v3') || 0;
    highEl.innerText = "BEST: " + highScore;

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(type) {
      if (audioCtx.state === 'suspended') audioCtx.resume();
      const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
      osc.connect(gain); gain.connect(audioCtx.destination);
      if (type === 'move') {
        osc.frequency.setValueAtTime(120, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.02, audioCtx.currentTime);
        osc.start(); osc.stop(audioCtx.currentTime + 0.04);
        if (navigator.vibrate) navigator.vibrate(5);
      } else if (type === 'clear') {
        osc.type = 'square'; osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        osc.start(); osc.stop(audioCtx.currentTime + 0.3);
        if (navigator.vibrate) navigator.vibrate([30, 50, 30]);
      }
    }

    const tetrominos = {
      'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      'J': [[1,0,0],[1,1,1],[0,0,0]],
      'L': [[0,0,1],[1,1,1],[0,0,0]],
      'O': [[1,1],[1,1]],
      'S': [[0,1,1],[1,1,0],[0,0,0]],
      'Z': [[1,1,0],[0,1,1],[0,0,0]],
      'T': [[0,1,0],[1,1,1],[0,0,0]]
    };
    const colors = { 'I': '#0ff', 'O': '#ff0', 'T': '#a0f', 'S': '#0f0', 'Z': '#f00', 'J': '#00f', 'L': '#f70' };
    let playfield = Array.from({length: 20}, () => new Array(10).fill(0));

    function rotate(m) { return m.map((_, i) => m.map(row => row[i]).reverse()); }
    
    function isValid(m, r, c) {
      for (let y = 0; y < m.length; y++) {
        for (let x = 0; x < m[y].length; x++) {
          if (m[y][x] && (c+x < 0 || c+x >= 10 || r+y >= 20 || (r+y >= 0 && playfield[r+y][c+x]))) return false;
        }
      }
      return true;
    }

    function getNext() {
      const names = Object.keys(tetrominos);
      const name = names[Math.floor(Math.random() * names.length)];
      return { name, matrix: tetrominos[name], row: name === 'I' ? -1 : -2, col: 3 };
    }

    let tetromino = getNext();
    let startX, startY, isMoved;

    function togglePause() {
      if (gameOver) return location.reload();
      isPaused = !isPaused;
      pauseMsg.style.display = isPaused ? 'block' : 'none';
      if (!isPaused) requestAnimationFrame(loop);
    }

    canvas.addEventListener('pointerdown', e => {
      if (isPaused || gameOver) return;
      startX = e.clientX; startY = e.clientY; isMoved = false;
      canvas.setPointerCapture(e.pointerId);
    });

    canvas.addEventListener('pointermove', e => {
      if (gameOver || isPaused || startX === undefined) return;
      const dx = e.clientX - startX, dy = e.clientY - startY;
      if (Math.abs(dx) > grid * 0.7) {
        const dir = dx > 0 ? 1 : -1;
        if (isValid(tetromino.matrix, tetromino.row, tetromino.col + dir)) {
          tetromino.col += dir; startX = e.clientX; isMoved = true; playSound('move');
        }
      }
      if (dy > grid * 0.7) {
        if (isValid(tetromino.matrix, tetromino.row + 1, tetromino.col)) {
          tetromino.row++; startY = e.clientY; isMoved = true; playSound('move');
        }
      }
    });

    canvas.addEventListener('pointerup', () => {
      if (!isMoved && !gameOver && !isPaused) {
        const m = rotate(tetromino.matrix);
        if (isValid(m, tetromino.row, tetromino.col)) { tetromino.matrix = m; playSound('move'); }
      }
      startX = undefined;
    });

    function loop() {
      if (gameOver || isPaused) return;
      requestAnimationFrame(loop);
      context.clearRect(0,0,canvas.width,canvas.height);

      // –†–∏—Å—É–µ–º –ø–æ–ª–µ
      playfield.forEach((row, r) => row.forEach((cell, c) => {
        if (cell) { context.fillStyle = colors[cell]; context.fillRect(c*grid, r*grid, grid-1, grid-1); }
      }));

      // --- –õ–û–ì–ò–ö–ê –ü–†–ò–ó–†–ê–ö–ê ---
      let ghostRow = tetromino.row;
      while (isValid(tetromino.matrix, ghostRow + 1, tetromino.col)) {
        ghostRow++;
      }
      context.fillStyle = 'rgba(255, 255, 255, 0.15)'; // –¶–≤–µ—Ç —Ç–µ–Ω–∏
      tetromino.matrix.forEach((row, r) => row.forEach((v, c) => {
        if (v && ghostRow + r >= 0) context.fillRect((tetromino.col+c)*grid, (ghostRow+r)*grid, grid-1, grid-1);
      }));

      // –í—Å–ø—ã—à–∫–∞ –ª–∏–Ω–∏–π
      if (flashLines.length > 0) {
        context.fillStyle = 'rgba(255,255,255,0.4)';
        flashLines.forEach(r => context.fillRect(0, r*grid, canvas.width, grid));
        if (count % 3 === 0) flashLines = [];
      }

      // –ü–∞–¥–µ–Ω–∏–µ
      let dropSpeed = Math.max(10, 35 - Math.floor(score / 500)); // –°–∫–æ—Ä–æ—Å—Ç—å —Ä–∞—Å—Ç–µ—Ç –∫–∞–∂–¥—ã–µ 500 –æ—á–∫–æ–≤
      if (++count > dropSpeed) {
        tetromino.row++; count = 0;
        if (!isValid(tetromino.matrix, tetromino.row, tetromino.col)) {
          tetromino.row--;
          tetromino.matrix.forEach((row, r) => row.forEach((v, c) => {
            if (v) {
              if (tetromino.row + r < 0) {
                gameOver = true;
                endPhrase = funnyPhrases[Math.floor(Math.random() * funnyPhrases.length)];
                if (score > highScore) localStorage.setItem('tetris-best-v3', score);
              }
              else playfield[tetromino.row+r][tetromino.col+c] = tetromino.name;
            }
          }));
          for (let r = 19; r >= 0; r--) {
            if (playfield[r].every(v => !!v)) {
              playSound('clear'); flashLines.push(r);
              score += 100; scoreEl.innerText = "SCORE: " + score;
              playfield.splice(r, 1); playfield.unshift(new Array(10).fill(0)); r++;
            }
          }
          tetromino = getNext();
        }
      }

      // –†–∏—Å—É–µ–º –∞–∫—Ç–∏–≤–Ω—É—é —Ñ–∏–≥—É—Ä—É
      context.fillStyle = colors[tetromino.name];
      tetromino.matrix.forEach((row, r) => row.forEach((v, c) => {
        if (v && tetromino.row + r >= 0) context.fillRect((tetromino.col+c)*grid, (tetromino.row+r)*grid, grid-1, grid-1);
      }));

      if (gameOver) {
        context.fillStyle = 'rgba(0,0,0,0.85)'; context.fillRect(0,0,canvas.width,canvas.height);
        context.fillStyle = '#f0f'; context.font = 'bold 22px sans-serif'; context.textAlign = 'center';
        context.fillText(endPhrase, 160, 300);
        context.fillStyle = '#fff'; context.font = '14px sans-serif';
        context.fillText('–ñ–ú–ò –ù–ê SCORE, –ß–¢–û–ë–´ –û–¢–û–ú–°–¢–ò–¢–¨', 160, 350);
      }
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
        osc.type = 'triangle'; osc.frequency.setValueAtTime(400, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        osc.start(); osc.stop(audioCtx.currentTime + 0.1);
      } else if (type === 'clear') {
        osc.type = 'sine'; osc.frequency.setValueAtTime(500, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.4);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.4);
        osc.start(); osc.stop(audioCtx.currentTime + 0.4);
      }
    }

    const tetrominos = {
      'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      'J': [[1,0,0],[1,1,1],[0,0,0]],
      'L': [[0,0,1],[1,1,1],[0,0,0]],
      'O': [[1,1],[1,1]],
      'S': [[0,1,1],[1,1,0],[0,0,0]],
      'Z': [[1,1,0],[0,1,1],[0,0,0]],
      'T': [[0,1,0],[1,1,1],[0,0,0]]
    };

    const colors = { 'I': '#0ff', 'O': '#ff0', 'T': '#a0f', 'S': '#0f0', 'Z': '#f00', 'J': '#00f', 'L': '#f70' };
    let playfield = Array.from({length: 20}, () => new Array(10).fill(0));

    function rotate(matrix) { return matrix.map((_, i) => matrix.map(row => row[i]).reverse()); }

    function isValid(matrix, cellRow, cellCol) {
      for (let r = 0; r < matrix.length; r++) {
        for (let c = 0; c < matrix[r].length; c++) {
          if (matrix[r][c]) {
            let pr = cellRow + r, pc = cellCol + c;
            if (pc < 0 || pc >= 10 || pr >= 20 || (pr >= 0 && playfield[pr][pc])) return false;
          }
        }
      }
      return true;
    }

    let sequence = [];
    function getNext() {
      if (!sequence.length) sequence = ['I','J','L','O','S','T','Z'].sort(() => Math.random() - 0.5);
      const name = sequence.pop();
      return { name, matrix: tetrominos[name], row: name === 'I' ? -1 : -2, col: 3 };
    }

    let tetromino = getNext();
    let startX, startY, isMoved;

    canvas.addEventListener('pointerdown', e => {
      startX = e.clientX; startY = e.clientY; isMoved = false;
      canvas.setPointerCapture(e.pointerId);
    });

    canvas.addEventListener('pointermove', e => {
      if (gameOver || startX === undefined) return;
      const dx = e.clientX - startX, dy = e.clientY - startY;
      if (Math.abs(dx) > grid * 0.8) {
        const dir = dx > 0 ? 1 : -1;
        if (isValid(tetromino.matrix, tetromino.row, tetromino.col + dir)) {
          tetromino.col += dir; startX = e.clientX; isMoved = true; playSound('move');
        }
      }
      if (dy > grid * 0.8) {
        if (isValid(tetromino.matrix, tetromino.row + 1, tetromino.col)) {
          tetromino.row++; startY = e.clientY; isMoved = true; playSound('move');
        }
      }
    });

    canvas.addEventListener('pointerup', e => {
      if (!isMoved && !gameOver) {
        const m = rotate(tetromino.matrix);
        if (isValid(m, tetromino.row, tetromino.col)) { tetromino.matrix = m; playSound('rotate'); }
      }
      startX = undefined;
    });

    function loop() {
      if (gameOver) {
        context.fillStyle = 'rgba(0,0,0,0.7)'; context.fillRect(0,0,canvas.width,canvas.height);
        context.fillStyle = 'white'; context.font = '32px sans-serif'; context.textAlign = 'center';
        context.fillText('GAME OVER', 160, 320); return;
      }
      requestAnimationFrame(loop);
      context.clearRect(0,0,canvas.width,canvas.height);

      // –†–∏—Å—É–µ–º –ø–æ–ª–µ
      playfield.forEach((row, r) => row.forEach((cell, c) => {
        if (cell) {
          context.fillStyle = colors[cell];
          context.fillRect(c*grid, r*grid, grid-1, grid-1);
        }
      }));

      // –ê–Ω–∏–º–∞—Ü–∏—è –≤—Å–ø—ã—à–∫–∏ –ª–∏–Ω–∏–π
      if (flashLines.length > 0) {
        context.fillStyle = 'rgba(255,255,255,0.5)';
        flashLines.forEach(r => context.fillRect(0, r*grid, canvas.width, grid));
        if (count % 2 === 0) flashLines = []; // –ë—ã—Å—Ç—Ä–æ —É–±–∏—Ä–∞–µ–º –≤—Å–ø—ã—à–∫—É
      }

      // –ü–∞–¥–µ–Ω–∏–µ
      if (++count > 35) {
        tetromino.row++; count = 0;
        if (!isValid(tetromino.matrix, tetromino.row, tetromino.col)) {
          tetromino.row--;
          tetromino.matrix.forEach((row, r) => row.forEach((v, c) => {
            if (v) {
              if (tetromino.row + r < 0) gameOver = true;
              else playfield[tetromino.row+r][tetromino.col+c] = tetromino.name;
            }
          }));
          // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–Ω–∏–π
          for (let r = 19; r >= 0; r--) {
            if (playfield[r].every(v => !!v)) {
              flashLines.push(r); playSound('clear');
              score += 100; document.getElementById('score').innerText = "SCORE: " + score;
              playfield.splice(r, 1); playfield.unshift(new Array(10).fill(0)); r++;
            }
          }
          tetromino = getNext();
        }
      }

      // –†–∏—Å—É–µ–º –∞–∫—Ç–∏–≤–Ω—É—é —Ñ–∏–≥—É—Ä—É
      context.fillStyle = colors[tetromino.name];
      tetromino.matrix.forEach((row, r) => row.forEach((v, c) => {
        if (v && tetromino.row + r >= 0) context.fillRect((tetromino.col+c)*grid, (tetromino.row+r)*grid, grid-1, grid-1);
      }));
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
